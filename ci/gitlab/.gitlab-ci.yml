image: # Indicates the image you need for your project, based on the language you are using.

stages:
  - tests
  - deploy
  - release

variables:
  # Base folder of cached dependencies for different managers.
  DEPS_CACHE: "$CI_PROJECT_DIR/.cache/deps"
  # Specific subfolder where we save the Python wheels.
  PIP_WHEELHOUSE: "$DEPS_CACHE/pip/wheelhouse"

default:
  cache:
    # A single global cache is defined based on the Python dependency file.
    # The key is regenerated only if "files" changes, which avoids invalidating the cache unnecessarily.
    - key:
        files: ["requirements.txt", "poetry.lock"]
      paths: [ $DEPS_CACHE/pip ]
      policy: pull-push   # Retrieves cache at startup and updates it at startup.

tests:
  stage: tests
  before_script:
    # Prepare your project for test execution (install dependencies, configurations, etc).
    # ...
  script:
    # Add the commands you need for test execution.
    # ...
  rules:
    # This job will only run if all of these conditions are met:
    # 1. The action that triggered the pipeline is a 'push'.
    # 2. The action that triggered the pipeline is a 'merge request'.
    # 2. Only when the commit branch is NOT 'main'.
    # 3. When this commit has a valid previous commit, a SHA of zeros indicates that no previous commit existed, indicating that 
    # a branch has been created and does not yet contain any changes. With this condition we avoid executing the job in those initial situations.
    - if: $CI_COMMIT_BRANCH != "main" && $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_COMMIT_BEFORE_SHA != "0000000000000000000000000000000000000000"
      # Indicates that the flow always runs, regardless of whether flows in previous stages failed.
      when: always
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      # Indicates that the flow always runs, regardless of whether flows in previous stages failed.
      when: always
    # If the conditions are not met, the job never runs.
    - when: never

deploy_development_env:
  stage: deploy
  image: alpine:latest
  before_script:
    # Prepare the environment to begin the deployment process (install and configure CI tools for deployment based on the service you use).
    # ...
  script:
    # Add the commands you need to start the deployment.
    # ...
  rules:
    # This job will only run if all of these conditions are met:
    # 1. The commit is on the 'develop' branch.
    # 2. The action that triggered the pipeline is a 'push'.
    # 3. The 'develop' branch is protected in GitLab.
    - if: $CI_COMMIT_BRANCH == "develop" && $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_PROTECTED == "true"
      # Indicates that the flow will only be executed if all flows from previous stages have completed successfully.
      when: on_success
    # If the conditions are not met, the job never runs.
    - when: never

deploy_production_env:
  stage: deploy
  image: alpine:latest
  before_script:
    # Prepare the environment to begin the deployment process (install and configure CI tools for deployment based on the service you use).
    # ...
  script:
    # Add the commands you need to start the deployment.
    # ...
  rules:
    # This job will only run if all of these conditions are met:
    # 1. The commit is on the 'main' branch.
    # 2. The action that triggered the pipeline is a 'push'.
    # 3. The 'main' branch is protected in GitLab.
    - if: $CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_PROTECTED == "true"
      # Indicates that the flow will only be executed if all flows from previous stages have completed successfully.
      when: on_success
    # If the conditions are not met, the job never runs.
    - when: never

publish_release:
  stage: release
  image: node:20
  variables:
    # It is crucial for semantic-release to correctly analyze changes.
    GIT_STRATEGY: fetch
    # Turn off to get full history.
    GIT_DEPTH: 0
  before_script:
    # Install semantic-release and the necessary plugins without saving them to a package.json.
    # These plugins allow you to analyze commits, generate release notes, update the changelog,
    # create Git tags, and publish the release to GitLab.
    - npm install --no-save semantic-release @semantic-release/commit-analyzer @semantic-release/release-notes-generator @semantic-release/changelog @semantic-release/git @semantic-release/gitlab @semantic-release/gitlab conventional-changelog-conventionalcommits
  script:
    # The following commented line is used to test the process without creating an actual release.
    # - npx semantic-release --dry-run
    # Run semantic-release to automate the release process.
    - npx semantic-release
  rules:
    # This job will only run if all of these conditions are met:
    # 1. The commit is on the 'main' branch.
    # 2. The action that triggered the pipeline is a 'push'.
    # 3. The 'main' branch is protected in GitLab.
    - if: $CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_PROTECTED == "true"
      # Indicates that the flow will only be executed if all flows from previous stages have completed successfully.
      when: on_success
    # If the conditions are not met, the job never runs.
    - when: never
